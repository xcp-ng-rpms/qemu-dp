patch add-qemu-dp.patch

From: Stefano Panella <Stefano.Panella@citrix.com>

diff --git a/.gitignore b/.gitignore
index cf65316..74f77b3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -134,3 +134,9 @@ trace-dtrace-root.h
 trace-dtrace-root.dtrace
 trace-ust-all.h
 trace-ust-all.c
+/dp-qapi-types.[ch]
+/dp-qapi-visit.[ch]
+/dp-qapi-event.[ch]
+/dp-qmp-commands.h
+/dp-qmp-marshal.c
+/qemu-dp
diff --git a/Makefile b/Makefile
index 81447b1..a261c12 100644
--- a/Makefile
+++ b/Makefile
@@ -57,6 +57,10 @@ GENERATED_FILES += qmp-marshal.c qapi-types.c qapi-visit.c qapi-event.c
 GENERATED_FILES += qmp-introspect.h
 GENERATED_FILES += qmp-introspect.c
 
+GENERATED_FILES += dp-qapi-types.h dp-qapi-visit.h dp-qapi-event.h
+GENERATED_FILES += dp-qapi-types.c dp-qapi-visit.c dp-qapi-event.c
+GENERATED_FILES += dp-qapi-event.h dp-qmp-marshal.c dp-qmp-commands.h
+
 GENERATED_FILES += trace/generated-tcg-tracers.h
 
 GENERATED_FILES += trace/generated-helpers-wrappers.h
@@ -366,6 +370,13 @@ Makefile: $(version-obj-y)
 
 libqemustub.a: $(stub-obj-y)
 libqemuutil.a: $(util-obj-y) $(trace-obj-y)
+libqemuutildp.a: $(filter-out qmp-introspect.o qapi-types.o qapi-visit.o qapi-event.o,$(util-obj-y)) \
+    $(trace-obj-y)
+libqemucrypto.a: $(crypto-obj-y)
+libqemuchardev.a: $(chardev-obj-y)
+libqemublock.a: $(block-obj-y)
+libqemuio.a: $(io-obj-y)
+libqemuqom.a: $(qom-obj-y)
 
 ######################################################################
 
@@ -376,6 +387,27 @@ qemu-img.o: qemu-img-cmds.h
 qemu-img$(EXESUF): qemu-img.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-nbd$(EXESUF): qemu-nbd.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 qemu-io$(EXESUF): qemu-io.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+qemu-dp$(EXESUF): \
+    qemu-dp.o dp-monitor.o dp-lib.o dp-stub.o \
+    dp-qapi-event.o dp-qapi-types.o dp-qapi-visit.o dp-qmp-marshal.o \
+    hw/block/xen_disk.o hw/xen/xen_devconfig.o hw/xen/xen_backend.o \
+    hw/xen/xen_pvdev.o \
+    blockdev-nbd.o blockdev.o block/stream.o iothread.o \
+    hw/core/qdev.o hw/core/bus.o hw/core/hotplug.o hw/core/qdev-properties.o \
+    hw/core/irq.o hw/core/fw-path-provider.o hw/core/reset.o \
+    chardev/char-socket.o \
+    libqemuchardev.a \
+    libqemublock.a \
+    libqemuio.a \
+    libqemuqom.a \
+    libqemuutildp.a \
+    libqemucrypto.a \
+    stubs/crypto.o \
+    block/rbd.o \
+    libqemustub.a
+qemu-dp$(EXESUF): LIBS = -lglib-2.0 -lz -laio -lxenevtchn -lxengnttab -lxenstore -lxenctrl -lxenforeignmemory
+
+all: qemu-dp$(EXESUF)
 
 qemu-bridge-helper$(EXESUF): qemu-bridge-helper.o $(COMMON_LDADDS)
 
@@ -440,6 +470,35 @@ $(qapi-modules) $(SRC_PATH)/scripts/qapi-introspect.py $(qapi-py)
 		$(gen-out-type) -o "." $<, \
 		"GEN","$@")
 
+dp-qapi-types.c dp-qapi-types.h :\
+$(SRC_PATH)/dp.json $(qapi-modules) $(SRC_PATH)/scripts/qapi-types.py $(qapi-py)
+	$(call quiet-command,set -e; \
+		$(PYTHON) $(SRC_PATH)/scripts/qapi-types.py \
+		$(gen-out-type) -o "." -p "dp-" -b $<; \
+		sed -i '/^#include "dp-qapi-types.h"$$/d' "$@", \
+		"GEN","$@")
+dp-qapi-visit.c dp-qapi-visit.h :\
+$(SRC_PATH)/dp.json $(qapi-modules) $(SRC_PATH)/scripts/qapi-visit.py $(qapi-py)
+	$(call quiet-command,set -e; \
+		$(PYTHON) $(SRC_PATH)/scripts/qapi-visit.py \
+		$(gen-out-type) -o "." -p "dp-" -b $<; \
+		sed -i '/^#include "dp-qapi-types.h"$$/d' "$@", \
+		"GEN","$@")
+dp-qmp-commands.h dp-qmp-marshal.c :\
+$(SRC_PATH)/dp.json $(qapi-modules) $(SRC_PATH)/scripts/qapi-commands.py $(qapi-py)
+	$(call quiet-command,set -e; \
+		$(PYTHON) $(SRC_PATH)/scripts/qapi-commands.py \
+		$(gen-out-type) -o "." -p "dp-" $<; \
+		sed -i '/^#include "dp-qapi-types.h"$$/d' "$@", \
+		"GEN","$@")
+dp-qapi-event.c dp-qapi-event.h :\
+$(SRC_PATH)/dp.json $(qapi-modules) $(SRC_PATH)/scripts/qapi-event.py $(qapi-py)
+	$(call quiet-command,set -e; \
+		$(PYTHON) $(SRC_PATH)/scripts/qapi-event.py \
+		$(gen-out-type) -o "." -p "dp-" $<; \
+		sed -i '/^#include "dp-qapi-types.h"$$/d' "$@", \
+		"GEN","$@")
+
 QGALIB_GEN=$(addprefix qga/qapi-generated/, qga-qapi-types.h qga-qapi-visit.h qga-qmp-commands.h)
 $(qga-obj-y): $(QGALIB_GEN)
 
@@ -489,6 +548,7 @@ clean:
 	rm -f *.msi
 	find . \( -name '*.so' -o -name '*.dll' -o -name '*.mo' -o -name '*.[oda]' \) -type f -exec rm {} +
 	rm -f $(filter-out %.tlb,$(TOOLS)) $(HELPERS-y) qemu-ga TAGS cscope.* *.pod *~ */*~
+	rm -f qemu-dp
 	rm -f fsdev/*.pod
 	rm -f qemu-img-cmds.h
 	rm -f ui/shader/*-vert.h ui/shader/*-frag.h
@@ -624,6 +684,7 @@ endif
 ifeq ($(CONFIG_GTK),y)
 	$(MAKE) -C po $@
 endif
+	$(call install-prog,qemu-dp$(EXESUF),$(DESTDIR)$(bindir))
 	$(INSTALL_DIR) "$(DESTDIR)$(qemu_datadir)/keymaps"
 	set -e; for x in $(KEYMAPS); do \
 		$(INSTALL_DATA) $(SRC_PATH)/pc-bios/keymaps/$$x "$(DESTDIR)$(qemu_datadir)/keymaps"; \
diff --git a/dp-lib.c b/dp-lib.c
new file mode 100644
index 0000000..67a08d5
--- /dev/null
+++ b/dp-lib.c
@@ -0,0 +1,128 @@
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "qapi/qmp/qjson.h"
+#include "qapi/qmp/qerror.h"
+#include "hw/qdev.h"
+#include "monitor/qdev.h"
+#include "sysemu/block-backend.h"
+
+static Object *qdev_get_peripheral(void)
+{
+    static Object *dev;
+
+    if (dev == NULL) {
+        dev = container_get(qdev_get_machine(), "/peripheral");
+    }
+
+    return dev;
+}
+
+static Object *qdev_get_peripheral_anon(void)
+{
+    static Object *dev;
+
+    if (dev == NULL) {
+        dev = container_get(qdev_get_machine(), "/peripheral-anon");
+    }
+
+    return dev;
+}
+
+static DeviceState *find_device_state(const char *id, Error **errp)
+{
+    Object *obj;
+
+    if (id[0] == '/') {
+        obj = object_resolve_path(id, NULL);
+    } else {
+        char *root_path = object_get_canonical_path(qdev_get_peripheral());
+        char *path = g_strdup_printf("%s/%s", root_path, id);
+
+        g_free(root_path);
+        obj = object_resolve_path_type(path, TYPE_DEVICE, NULL);
+        g_free(path);
+    }
+
+    if (!obj) {
+        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,
+                  "Device '%s' not found", id);
+        return NULL;
+    }
+
+    if (!object_dynamic_cast(obj, TYPE_DEVICE)) {
+        error_setg(errp, "%s is not a hotpluggable device", id);
+        return NULL;
+    }
+
+    return DEVICE(obj);
+}
+
+BlockBackend *blk_by_qdev_id(const char *id, Error **errp)
+{
+    DeviceState *dev;
+    BlockBackend *blk;
+
+    dev = find_device_state(id, errp);
+    if (dev == NULL) {
+        return NULL;
+    }
+
+    blk = blk_by_dev(dev);
+    if (!blk) {
+        error_setg(errp, "Device does not have a block device backend");
+    }
+    return blk;
+}
+
+void qdev_set_id(DeviceState *dev, const char *id)
+{
+    if (id) {
+        dev->id = id;
+    }
+
+    if (dev->id) {
+        object_property_add_child(qdev_get_peripheral(), dev->id,
+                                  OBJECT(dev), NULL);
+    } else {
+        static int anon_count;
+        gchar *name = g_strdup_printf("device[%d]", anon_count++);
+        object_property_add_child(qdev_get_peripheral_anon(), name,
+                                  OBJECT(dev), NULL);
+        g_free(name);
+    }
+}
+
+void qdev_unplug(DeviceState *dev, Error **errp)
+{
+    DeviceClass *dc = DEVICE_GET_CLASS(dev);
+    HotplugHandler *hotplug_ctrl;
+    HotplugHandlerClass *hdc;
+
+    if (dev->parent_bus && !qbus_is_hotpluggable(dev->parent_bus)) {
+        error_setg(errp, QERR_BUS_NO_HOTPLUG, dev->parent_bus->name);
+        return;
+    }
+
+    if (!dc->hotpluggable) {
+        error_setg(errp, QERR_DEVICE_NO_HOTPLUG,
+                   object_get_typename(OBJECT(dev)));
+        return;
+    }
+
+    qdev_hot_removed = true;
+
+    hotplug_ctrl = qdev_get_hotplug_handler(dev);
+    /* hotpluggable device MUST have HotplugHandler, if it doesn't
+     * then something is very wrong with it */
+    g_assert(hotplug_ctrl);
+
+    /* If device supports async unplug just request it to be done,
+     * otherwise just remove it synchronously */
+    hdc = HOTPLUG_HANDLER_GET_CLASS(hotplug_ctrl);
+    if (hdc->unplug_request) {
+        hotplug_handler_unplug_request(hotplug_ctrl, dev, errp);
+    } else {
+        hotplug_handler_unplug(hotplug_ctrl, dev, errp);
+    }
+}
diff --git a/dp-monitor.c b/dp-monitor.c
new file mode 100644
index 0000000..5e79a1f
--- /dev/null
+++ b/dp-monitor.c
@@ -0,0 +1,295 @@
+#include "qemu/osdep.h"
+#include "qemu-version.h"
+#include "qemu/thread.h"
+#include "chardev/char-fe.h"
+#include "qapi/error.h"
+#include "qapi/qmp/qjson.h"
+#include "qapi/qmp/dispatch.h"
+#include "qapi/qmp/json-parser.h"
+#include "qapi/qmp/json-streamer.h"
+#include "qapi/qmp/qerror.h"
+#include "dp-qmp-commands.h"
+#include "monitor/dp-monitor.h"
+#include "qapi/qmp/dispatch.h"
+#include "trace-root.h"
+#include "trace/control.h"
+#ifdef CONFIG_TRACE_SIMPLE
+#include "trace/simple.h"
+#endif
+
+/* Most of this code has been taken from monitor.c */
+
+QemuRecMutex monitor_rec_lock;
+
+typedef struct DPMonitor {
+    CharBackend chr;
+    bool skip_flush;
+    QemuMutex out_lock;
+    QString *outbuf;
+    guint out_watch;
+    JSONMessageParser parser;
+    /*
+     * When a client connects, we're in capabilities negotiation mode.
+     * When command qmp_capabilities succeeds, we go into command
+     * mode.
+     */
+    QmpCommandList *commands;
+} DPMonitor;
+
+static QmpCommandList qmp_commands, qmp_cap_negotiation_commands;
+static DPMonitor *mon;
+
+static void dp_monitor_flush_locked(DPMonitor *mon);
+
+static gboolean dp_monitor_unblocked(GIOChannel *chan, GIOCondition cond,
+                                  void *opaque)
+{
+    DPMonitor *mon = opaque;
+
+    qemu_mutex_lock(&mon->out_lock);
+    mon->out_watch = 0;
+    dp_monitor_flush_locked(mon);
+    qemu_mutex_unlock(&mon->out_lock);
+    return FALSE;
+}
+
+/* Called with m->out_lock held.  */
+static void dp_monitor_flush_locked(DPMonitor *m)
+{
+    int rc;
+    size_t len;
+    const char *buf;
+
+    if (m->skip_flush) {
+        return;
+    }
+
+    buf = qstring_get_str(m->outbuf);
+    len = qstring_get_length(m->outbuf);
+
+    if (len) {
+        rc = qemu_chr_fe_write(&m->chr, (const uint8_t *) buf, len);
+        if ((rc < 0 && errno != EAGAIN) || (rc == len)) {
+            /* all flushed or error */
+            QDECREF(m->outbuf);
+            m->outbuf = qstring_new();
+            return;
+        }
+        if (rc > 0) {
+            /* partial write */
+            QString *tmp = qstring_from_str(buf + rc);
+            QDECREF(m->outbuf);
+            m->outbuf = tmp;
+        }
+        if (m->out_watch == 0) {
+            m->out_watch =
+                qemu_chr_fe_add_watch(&m->chr, G_IO_OUT | G_IO_HUP,
+                                      dp_monitor_unblocked, m);
+        }
+    }
+}
+
+/* flush at every end of line */
+static void dp_monitor_puts(DPMonitor *m, const char *str)
+{
+    char c;
+
+    qemu_mutex_lock(&m->out_lock);
+    for(;;) {
+        c = *str++;
+        if (c == '\0')
+            break;
+        if (c == '\n') {
+            qstring_append_chr(m->outbuf, '\r');
+        }
+        qstring_append_chr(m->outbuf, c);
+        if (c == '\n') {
+            dp_monitor_flush_locked(m);
+        }
+    }
+    qemu_mutex_unlock(&m->out_lock);
+}
+
+static void dp_monitor_json_emitter(DPMonitor *m, const QObject *data)
+{
+    QString *json;
+
+    json = qobject_to_json(data);
+    assert(json != NULL);
+
+    qstring_append_chr(json, '\n');
+    dp_monitor_puts(m, qstring_get_str(json));
+
+    QDECREF(json);
+}
+
+static void handle_qmp_command(JSONMessageParser *parser, GQueue *tokens)
+{
+    QObject *req, *rsp = NULL, *id = NULL;
+    QDict *qdict = NULL;
+    Error *err = NULL;
+
+    req = json_parser_parse_err(tokens, NULL, &err);
+    if (!req && !err) {
+        /* json_parser_parse_err() sucks: can fail without setting @err */
+        error_setg(&err, QERR_JSON_PARSING);
+    }
+    if (err) {
+        goto err_out;
+    }
+
+    qdict = qobject_to_qdict(req);
+    if (qdict) {
+        id = qdict_get(qdict, "id");
+        qobject_incref(id);
+        qdict_del(qdict, "id");
+    } /* else will fail qmp_dispatch() */
+
+    qemu_rec_mutex_lock(&monitor_rec_lock);
+
+    QString *req_json = qobject_to_json(req);
+    trace_dp_handle_qmp_command_enter(qstring_get_str(req_json));
+
+    rsp = qmp_dispatch(mon->commands, req);
+
+    trace_dp_handle_qmp_command_exit(qstring_get_str(req_json));
+    QDECREF(req_json);
+
+    qemu_rec_mutex_unlock(&monitor_rec_lock);
+
+err_out:
+    if (err) {
+        qdict = qdict_new();
+        qdict_put_obj(qdict, "error", qmp_build_error_object(err));
+        error_free(err);
+        rsp = QOBJECT(qdict);
+    }
+
+    if (rsp) {
+        if (id) {
+            qdict_put_obj(qobject_to_qdict(rsp), "id", id);
+            id = NULL;
+        }
+
+        dp_monitor_json_emitter(mon, rsp);
+    }
+
+    qobject_decref(id);
+    qobject_decref(rsp);
+    qobject_decref(req);
+}
+
+static QObject *get_qmp_greeting(void)
+{
+    QObject *ver = NULL;
+
+    qmp_marshal_query_version(NULL, &ver, NULL);
+
+    return qobject_from_jsonf("{'QMP': {'version': %p, 'capabilities': []}}",
+                              ver);
+}
+
+static void dp_monitor_qmp_event(void *opaque, int event)
+{
+    QObject *data;
+
+    switch (event) {
+    case CHR_EVENT_OPENED:
+        mon->commands = &qmp_cap_negotiation_commands;
+        data = get_qmp_greeting();
+        dp_monitor_json_emitter(mon, data);
+        qobject_decref(data);
+        break;
+    case CHR_EVENT_CLOSED:
+        json_message_parser_destroy(&mon->parser);
+        json_message_parser_init(&mon->parser, handle_qmp_command);
+        break;
+    }
+}
+
+static int dp_monitor_can_read(void *opaque)
+{
+    return 1;
+}
+
+static void dp_monitor_qmp_read(void *opaque, const uint8_t *buf, int size)
+{
+    json_message_parser_feed(&mon->parser, (const char *)buf, size);
+}
+
+static void query_commands_cb(QmpCommand *cmd, void *opaque)
+{
+    CommandInfoList *info, **list = opaque;
+
+    if (!cmd->enabled) {
+        return;
+    }
+
+    info = g_malloc0(sizeof(*info));
+    info->value = g_malloc0(sizeof(*info->value));
+    info->value->name = g_strdup(cmd->name);
+    info->next = *list;
+    *list = info;
+}
+
+CommandInfoList *qmp_query_commands(Error **errp)
+{
+    CommandInfoList *list = NULL;
+
+    qmp_for_each_command(mon->commands, query_commands_cb, &list);
+
+    return list;
+}
+
+VersionInfo *qmp_query_version(Error **errp)
+{
+    VersionInfo *info = g_new0(VersionInfo, 1);
+
+    info->qemu = g_new0(VersionTriple, 1);
+    info->qemu->major = QEMU_VERSION_MAJOR;
+    info->qemu->minor = QEMU_VERSION_MINOR;
+    info->qemu->micro = QEMU_VERSION_MICRO;
+    info->package = g_strdup(QEMU_PKGVERSION);
+
+    return info;
+}
+
+void qmp_qmp_capabilities(Error **errp)
+{
+    if (mon->commands == &qmp_commands) {
+        error_set(errp, ERROR_CLASS_COMMAND_NOT_FOUND,
+                  "Capabilities negotiation is already complete, command "
+                  "ignored");
+        return;
+    }
+
+    mon->commands = &qmp_commands;
+}
+
+void dp_monitor_init(Chardev *chr)
+{
+    mon = g_malloc(sizeof(DPMonitor));
+    memset(mon, 0, sizeof(DPMonitor));
+    qemu_mutex_init(&mon->out_lock);
+    qemu_rec_mutex_init(&monitor_rec_lock);
+    mon->outbuf = qstring_new();
+    qemu_chr_fe_init(&mon->chr, chr, &error_abort);
+    QTAILQ_INIT(&qmp_cap_negotiation_commands);
+    qmp_register_command(&qmp_cap_negotiation_commands, "qmp_capabilities",
+                         qmp_marshal_qmp_capabilities, QCO_NO_OPTIONS);
+    dp_qmp_init_marshal(&qmp_commands);
+
+    qemu_chr_fe_set_handlers(&mon->chr, dp_monitor_can_read,
+            dp_monitor_qmp_read, dp_monitor_qmp_event, NULL, mon, NULL, true);
+    json_message_parser_init(&mon->parser, handle_qmp_command);
+
+}
+
+void dp_monitor_destroy(void)
+{
+    qemu_chr_fe_deinit(&mon->chr, false);
+    json_message_parser_destroy(&mon->parser);
+    QDECREF(mon->outbuf);
+    qemu_mutex_destroy(&mon->out_lock);
+    qemu_rec_mutex_destroy(&monitor_rec_lock);
+}
diff --git a/dp-stub.c b/dp-stub.c
new file mode 100644
index 0000000..33650b9
--- /dev/null
+++ b/dp-stub.c
@@ -0,0 +1,22 @@
+#include "qemu/osdep.h"
+#include <monitor/monitor.h>
+#include <net/net.h>
+#include <hw/xen/xen_backend.h>
+
+/* Provide empty stubs for functions not needed by qemu-dp. */
+
+struct XenDevOps xen_console_ops;
+struct XenDevOps xen_kbdmouse_ops;
+struct XenDevOps xen_9pfs_ops;
+struct XenDevOps xen_usb_ops;
+
+void monitor_printf(Monitor *mon, const char *fmt, ...)
+{
+}
+
+struct NetClientState;
+int net_hub_id_for_client(NetClientState *nc, int *id)
+{
+
+    return 0;
+}
diff --git a/dp.json b/dp.json
new file mode 100644
index 0000000..afc083f
--- /dev/null
+++ b/dp.json
@@ -0,0 +1,589 @@
+{ 'pragma': {
+    'name-case-whitelist': [
+        'QapiErrorClass'       # all members, visible through errors
+    ] } }
+
+# QAPI common definitions
+{ 'include': 'qapi/common.json' }
+
+# QAPI crypto definitions
+{ 'include': 'qapi/crypto.json' }
+
+# QAPI block definitions
+{ 'include': 'qapi/block.json' }
+
+##
+# @InetSocketAddressBase:
+#
+# @host: host part of the address
+# @port: port part of the address
+##
+{ 'struct': 'InetSocketAddressBase',
+  'data': {
+    'host': 'str',
+    'port': 'str' } }
+
+##
+# @InetSocketAddress:
+#
+# Captures a socket address or address range in the Internet namespace.
+#
+# @numeric: true if the host/port are guaranteed to be numeric,
+#           false if name resolution should be attempted. Defaults to false.
+#           (Since 2.9)
+#
+# @to: If present, this is range of possible addresses, with port
+#      between @port and @to.
+#
+# @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6
+#
+# @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6
+#
+# Since: 1.3
+##
+{ 'struct': 'InetSocketAddress',
+  'base': 'InetSocketAddressBase',
+  'data': {
+    '*numeric':  'bool',
+    '*to': 'uint16',
+    '*ipv4': 'bool',
+    '*ipv6': 'bool' } }
+
+##
+# @UnixSocketAddress:
+#
+# Captures a socket address in the local ("Unix socket") namespace.
+#
+# @path: filesystem path to use
+#
+# Since: 1.3
+##
+{ 'struct': 'UnixSocketAddress',
+  'data': {
+    'path': 'str' } }
+
+##
+# @VsockSocketAddress:
+#
+# Captures a socket address in the vsock namespace.
+#
+# @cid: unique host identifier
+# @port: port
+#
+# Note: string types are used to allow for possible future hostname or
+# service resolution support.
+#
+# Since: 2.8
+##
+{ 'struct': 'VsockSocketAddress',
+  'data': {
+    'cid': 'str',
+    'port': 'str' } }
+
+##
+# @SocketAddressLegacy:
+#
+# Captures the address of a socket, which could also be a named file descriptor
+#
+# Note: This type is deprecated in favor of SocketAddress.  The
+# difference between SocketAddressLegacy and SocketAddress is that the
+# latter is a flat union rather than a simple union. Flat is nicer
+# because it avoids nesting on the wire, i.e. that form has fewer {}.
+
+#
+# Since: 1.3
+##
+{ 'union': 'SocketAddressLegacy',
+  'data': {
+    'inet': 'InetSocketAddress',
+    'unix': 'UnixSocketAddress',
+    'vsock': 'VsockSocketAddress',
+    'fd': 'String' } }
+
+##
+# @SocketAddressType:
+#
+# Available SocketAddress types
+#
+# @inet:  Internet address
+#
+# @unix:  Unix domain socket
+#
+# Since: 2.9
+##
+{ 'enum': 'SocketAddressType',
+  'data': [ 'inet', 'unix', 'vsock', 'fd' ] }
+
+##
+# @SocketAddress:
+#
+# Captures the address of a socket, which could also be a named file
+# descriptor
+#
+# @type:       Transport type
+#
+# Since: 2.9
+##
+{ 'union': 'SocketAddress',
+  'base': { 'type': 'SocketAddressType' },
+  'discriminator': 'type',
+  'data': { 'inet': 'InetSocketAddress',
+            'unix': 'UnixSocketAddress',
+            'vsock': 'VsockSocketAddress',
+            'fd': 'String' } }
+
+##
+# @IoOperationType:
+#
+# An enumeration of the I/O operation types
+#
+# @read: read operation
+#
+# @write: write operation
+#
+# Since: 2.1
+##
+{ 'enum': 'IoOperationType',
+  'data': [ 'read', 'write' ] }
+
+##
+# @String:
+#
+# A fat type wrapping 'str', to be embedded in lists.
+#
+# Since: 1.2
+##
+{ 'struct': 'String',
+  'data': {
+    'str': 'str' } }
+
+##
+# @ChardevCommon:
+#
+# Configuration shared across all chardev backends
+#
+# @logfile: The name of a logfile to save output
+# @logappend: true to append instead of truncate
+#             (default to false to truncate)
+#
+# Since: 2.6
+##
+{ 'struct': 'ChardevCommon', 'data': { '*logfile': 'str',
+                                       '*logappend': 'bool' } }
+
+##
+# @ChardevFile:
+#
+# Configuration info for file chardevs.
+#
+# @in:  The name of the input file
+# @out: The name of the output file
+# @append: Open the file in append mode (default false to
+#          truncate) (Since 2.6)
+#
+# Since: 1.4
+##
+{ 'struct': 'ChardevFile', 'data': { '*in' : 'str',
+                                   'out' : 'str',
+                                   '*append': 'bool' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevHostdev:
+#
+# Configuration info for device and pipe chardevs.
+#
+# @device: The name of the special file for the device,
+#          i.e. /dev/ttyS0 on Unix or COM1: on Windows
+#
+# Since: 1.4
+##
+{ 'struct': 'ChardevHostdev', 'data': { 'device' : 'str' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevSocket:
+#
+# Configuration info for (stream) socket chardevs.
+#
+# @addr: socket address to listen on (server=true)
+#        or connect to (server=false)
+# @tls-creds: the ID of the TLS credentials object (since 2.6)
+# @server: create server socket (default: true)
+# @wait: wait for incoming connection on server
+#        sockets (default: false).
+# @nodelay: set TCP_NODELAY socket option (default: false)
+# @telnet: enable telnet protocol on server
+#          sockets (default: false)
+# @tn3270: enable tn3270 protocol on server
+#          sockets (default: false) (Since: 2.10)
+# @reconnect: For a client socket, if a socket is disconnected,
+#          then attempt a reconnect after the given number of seconds.
+#          Setting this to zero disables this function. (default: 0)
+#          (Since: 2.2)
+#
+# Since: 1.4
+##
+{ 'struct': 'ChardevSocket', 'data': { 'addr'       : 'SocketAddressLegacy',
+                                     '*tls-creds'  : 'str',
+                                     '*server'    : 'bool',
+                                     '*wait'      : 'bool',
+                                     '*nodelay'   : 'bool',
+                                     '*telnet'    : 'bool',
+                                     '*tn3270'    : 'bool',
+                                     '*reconnect' : 'int' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevUdp:
+#
+# Configuration info for datagram socket chardevs.
+#
+# @remote: remote address
+# @local: local address
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevUdp', 'data': { 'remote' : 'SocketAddressLegacy',
+                                  '*local' : 'SocketAddressLegacy' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevMux:
+#
+# Configuration info for mux chardevs.
+#
+# @chardev: name of the base chardev.
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevMux', 'data': { 'chardev' : 'str' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevStdio:
+#
+# Configuration info for stdio chardevs.
+#
+# @signal: Allow signals (such as SIGINT triggered by ^C)
+#          be delivered to qemu.  Default: true in -nographic mode,
+#          false otherwise.
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevStdio', 'data': { '*signal' : 'bool' },
+  'base': 'ChardevCommon' }
+
+
+##
+# @ChardevSpiceChannel:
+#
+# Configuration info for spice vm channel chardevs.
+#
+# @type: kind of channel (for example vdagent).
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevSpiceChannel', 'data': { 'type'  : 'str' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevSpicePort:
+#
+# Configuration info for spice port chardevs.
+#
+# @fqdn: name of the channel (see docs/spice-port-fqdn.txt)
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevSpicePort', 'data': { 'fqdn'  : 'str' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevVC:
+#
+# Configuration info for virtual console chardevs.
+#
+# @width:  console width,  in pixels
+# @height: console height, in pixels
+# @cols:   console width,  in chars
+# @rows:   console height, in chars
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevVC', 'data': { '*width'  : 'int',
+                                 '*height' : 'int',
+                                 '*cols'   : 'int',
+                                 '*rows'   : 'int' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevRingbuf:
+#
+# Configuration info for ring buffer chardevs.
+#
+# @size: ring buffer size, must be power of two, default is 65536
+#
+# Since: 1.5
+##
+{ 'struct': 'ChardevRingbuf', 'data': { '*size'  : 'int' },
+  'base': 'ChardevCommon' }
+
+##
+# @ChardevBackend:
+#
+# Configuration info for the new chardev backend.
+#
+# Since: 1.4 (testdev since 2.2, wctablet since 2.9)
+##
+{ 'union': 'ChardevBackend', 'data': { 'file'   : 'ChardevFile',
+                                       'serial' : 'ChardevHostdev',
+                                       'parallel': 'ChardevHostdev',
+                                       'pipe'   : 'ChardevHostdev',
+                                       'socket' : 'ChardevSocket',
+                                       'udp'    : 'ChardevUdp',
+                                       'pty'    : 'ChardevCommon',
+                                       'null'   : 'ChardevCommon',
+                                       'mux'    : 'ChardevMux',
+                                       'msmouse': 'ChardevCommon',
+                                       'wctablet' : 'ChardevCommon',
+                                       'braille': 'ChardevCommon',
+                                       'testdev': 'ChardevCommon',
+                                       'stdio'  : 'ChardevStdio',
+                                       'console': 'ChardevCommon',
+                                       'spicevmc' : 'ChardevSpiceChannel',
+                                       'spiceport' : 'ChardevSpicePort',
+                                       'vc'     : 'ChardevVC',
+                                       'ringbuf': 'ChardevRingbuf',
+                                       # next one is just for compatibility
+                                       'memory' : 'ChardevRingbuf' } }
+
+##
+# @Abort:
+#
+# This action can be used to test transaction failure.
+#
+# Since: 1.6
+##
+{ 'struct': 'Abort',
+  'data': { } }
+
+##
+# @ActionCompletionMode:
+#
+# An enumeration of Transactional completion modes.
+#
+# @individual: Do not attempt to cancel any other Actions if any Actions fail
+#              after the Transaction request succeeds. All Actions that
+#              can complete successfully will do so without waiting on others.
+#              This is the default.
+#
+# @grouped: If any Action fails after the Transaction succeeds, cancel all
+#           Actions. Actions do not complete until all Actions are ready to
+#           complete. May be rejected by Actions that do not support this
+#           completion mode.
+#
+# Since: 2.5
+##
+{ 'enum': 'ActionCompletionMode',
+  'data': [ 'individual', 'grouped' ] }
+
+##
+# @TransactionAction:
+#
+# A discriminated record of operations that can be performed with
+# @transaction. Action @type can be:
+#
+# - @abort: since 1.6
+# - @block-dirty-bitmap-add: since 2.5
+# - @block-dirty-bitmap-clear: since 2.5
+# - @blockdev-backup: since 2.3
+# - @blockdev-snapshot: since 2.5
+# - @blockdev-snapshot-internal-sync: since 1.7
+# - @blockdev-snapshot-sync: since 1.1
+# - @drive-backup: since 1.6
+#
+# Since: 1.1
+##
+{ 'union': 'TransactionAction',
+  'data': {
+       'abort': 'Abort',
+       'block-dirty-bitmap-add': 'BlockDirtyBitmapAdd',
+       'block-dirty-bitmap-clear': 'BlockDirtyBitmap',
+       'blockdev-backup': 'BlockdevBackup',
+       'blockdev-snapshot': 'BlockdevSnapshot',
+       'blockdev-snapshot-internal-sync': 'BlockdevSnapshotInternal',
+       'blockdev-snapshot-sync': 'BlockdevSnapshotSync',
+       'drive-backup': 'DriveBackup'
+   } }
+
+##
+# @TransactionProperties:
+#
+# Optional arguments to modify the behavior of a Transaction.
+#
+# @completion-mode: Controls how jobs launched asynchronously by
+#                   Actions will complete or fail as a group.
+#                   See @ActionCompletionMode for details.
+#
+# Since: 2.5
+##
+{ 'struct': 'TransactionProperties',
+  'data': {
+       '*completion-mode': 'ActionCompletionMode'
+  }
+}
+
+##
+# @QUORUM_FAILURE:
+#
+# Emitted by the Quorum block driver if it fails to establish a quorum
+#
+# @reference: device name if defined else node name
+#
+# @sector-num: number of the first sector of the failed read operation
+#
+# @sectors-count: failed read operation sector count
+#
+# Note: This event is rate-limited.
+#
+# Since: 2.0
+#
+# Example:
+#
+# <- { "event": "QUORUM_FAILURE",
+#      "data": { "reference": "usr1", "sector-num": 345435, "sectors-count": 5 },
+#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
+#
+##
+{ 'event': 'QUORUM_FAILURE',
+  'data': { 'reference': 'str', 'sector-num': 'int', 'sectors-count': 'int' } }
+
+##
+# @QUORUM_REPORT_BAD:
+#
+# Emitted to report a corruption of a Quorum file
+#
+# @type: quorum operation type (Since 2.6)
+#
+# @error: error message. Only present on failure. This field
+#         contains a human-readable error message. There are no semantics other
+#         than that the block layer reported an error and clients should not
+#         try to interpret the error string.
+#
+# @node-name: the graph node name of the block driver state
+#
+# @sector-num: number of the first sector of the failed read operation
+#
+# @sectors-count: failed read operation sector count
+#
+# Note: This event is rate-limited.
+#
+# Since: 2.0
+#
+# Example:
+#
+# 1. Read operation
+#
+# { "event": "QUORUM_REPORT_BAD",
+#      "data": { "node-name": "node0", "sector-num": 345435, "sectors-count": 5,
+#                "type": "read" },
+#      "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
+#
+# 2. Flush operation
+#
+# { "event": "QUORUM_REPORT_BAD",
+#      "data": { "node-name": "node0", "sector-num": 0, "sectors-count": 2097120,
+#                "type": "flush", "error": "Broken pipe" },
+#      "timestamp": { "seconds": 1456406829, "microseconds": 291763 } }
+#
+##
+{ 'event': 'QUORUM_REPORT_BAD',
+  'data': { 'type': 'QuorumOpType', '*error': 'str', 'node-name': 'str',
+            'sector-num': 'int', 'sectors-count': 'int' } }
+
+##
+# @LostTickPolicy:
+#
+# Policy for handling lost ticks in timer devices.
+#
+# @discard: throw away the missed tick(s) and continue with future injection
+#           normally.  Guest time may be delayed, unless the OS has explicit
+#           handling of lost ticks
+#
+# @delay: continue to deliver ticks at the normal rate.  Guest time will be
+#         delayed due to the late tick
+#
+# @merge: merge the missed tick(s) into one tick and inject.  Guest time
+#         may be delayed, depending on how the OS reacts to the merging
+#         of ticks
+#
+# @slew: deliver ticks at a higher rate to catch up with the missed tick. The
+#        guest time should not be delayed once catchup is complete.
+#
+# Since: 2.0
+##
+{ 'enum': 'LostTickPolicy',
+  'data': ['discard', 'delay', 'merge', 'slew' ] }
+
+##
+# @DEVICE_DELETED:
+#
+# Emitted whenever the device removal completion is acknowledged by the guest.
+# At this point, it's safe to reuse the specified device ID. Device removal can
+# be initiated by the guest or by HMP/QMP commands.
+#
+# @device: device name
+#
+# @path: device path
+#
+# Since: 1.5
+#
+# Example:
+#
+# <- { "event": "DEVICE_DELETED",
+#      "data": { "device": "virtio-net-pci-0",
+#                "path": "/machine/peripheral/virtio-net-pci-0" },
+#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
+#
+##
+{ 'event': 'DEVICE_DELETED',
+  'data': { '*device': 'str', 'path': 'str' } }
+
+##
+# @qmp_capabilities:
+#
+# Enable QMP capabilities.
+#
+# Arguments: None.
+#
+# Example:
+#
+# -> { "execute": "qmp_capabilities" }
+# <- { "return": {} }
+#
+# Notes: This command is valid exactly when first connecting: it must be
+# issued before any other command will be accepted, and will fail once the
+# monitor is accepting other commands. (see qemu docs/interop/qmp-spec.txt)
+#
+# Since: 0.13
+#
+##
+{ 'command': 'qmp_capabilities' }
+
+##
+# @quit:
+#
+# This command will cause the QEMU process to exit gracefully.  While every
+# attempt is made to send the QMP response before terminating, this is not
+# guaranteed.  When using this interface, a premature EOF would not be
+# unexpected.
+#
+# Since: 0.14.0
+#
+# Example:
+#
+# -> { "execute": "quit" }
+# <- { "return": {} }
+##
+{ 'command': 'quit' }
diff --git a/hw/block/trace-events b/hw/block/trace-events
index 962a3bf..287dc95 100644
--- a/hw/block/trace-events
+++ b/hw/block/trace-events
@@ -15,5 +15,9 @@ hd_geometry_guess(void *blk, uint32_t cyls, uint32_t heads, uint32_t secs, int t
 xen_disk_alloc(char *name) "%s"
 xen_disk_init(char *name) "%s"
 xen_disk_connect(char *name) "%s"
+xen_disk_connect_enter(char *name) "%s"
+xen_disk_connect_exit(char *name) "%s"
 xen_disk_disconnect(char *name) "%s"
+xen_disk_disconnect_enter(char *name) "%s"
+xen_disk_disconnect_exit(char *name) "%s"
 xen_disk_free(char *name) "%s"
diff --git a/hw/block/xen_disk.c b/hw/block/xen_disk.c
index d195c66..b73a68b 100644
--- a/hw/block/xen_disk.c
+++ b/hw/block/xen_disk.c
@@ -34,6 +34,8 @@
 #include "qapi/qmp/qstring.h"
 #include "qom/object_interfaces.h"
 #include "trace.h"
+#include "qapi/qmp/dispatch.h"
+
 
 /* ------------------------------------------------------------- */
 
@@ -1115,6 +1117,10 @@ static int blk_connect(struct XenDevice *xendev)
 
     trace_xen_disk_connect(xendev->name);
 
+    /* serialize with blockdev-snapshot-sync qmp command */
+    qemu_rec_mutex_lock(&monitor_rec_lock);
+    trace_xen_disk_connect_enter(xendev->name);
+
     /* read-only ? */
     if (blkdev->directiosafe) {
         qflags = BDRV_O_NOCACHE | BDRV_O_NATIVE_AIO;
@@ -1352,6 +1358,10 @@ static int blk_connect(struct XenDevice *xendev)
                   "remote port %d, local port %d\n",
                   blkdev->xendev.protocol, blkdev->nr_ring_ref,
                   blkdev->xendev.remote_port, blkdev->xendev.local_port);
+
+    trace_xen_disk_connect_exit(xendev->name);
+    qemu_rec_mutex_unlock(&monitor_rec_lock);
+
     return 0;
 }
 
@@ -1361,6 +1371,10 @@ static void blk_disconnect(struct XenDevice *xendev)
 
     trace_xen_disk_disconnect(xendev->name);
 
+    /* serialize with blockdev-snapshot-sync qmp command */
+    qemu_rec_mutex_lock(&monitor_rec_lock);
+    trace_xen_disk_disconnect_enter(xendev->name);
+
     aio_context_acquire(blkdev->ctx);
 
     if (blkdev->blk) {
@@ -1399,6 +1413,9 @@ static void blk_disconnect(struct XenDevice *xendev)
         }
         blkdev->feature_persistent = false;
     }
+
+    trace_xen_disk_disconnect_exit(xendev->name);
+    qemu_rec_mutex_unlock(&monitor_rec_lock);
 }
 
 static int blk_free(struct XenDevice *xendev)
diff --git a/hw/xen/xen_backend.c b/hw/xen/xen_backend.c
index b775ef3..a020a90 100644
--- a/hw/xen/xen_backend.c
+++ b/hw/xen/xen_backend.c
@@ -122,7 +122,6 @@ static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,
     xendev = g_malloc0(ops->size);
     object_initialize(&xendev->qdev, ops->size, TYPE_XENBACKEND);
     OBJECT(xendev)->free = g_free;
-    qdev_set_parent_bus(DEVICE(xendev), xen_sysbus);
     qdev_set_id(DEVICE(xendev), g_strdup_printf("xen-%s-%d", type, dev));
     qdev_init_nofail(DEVICE(xendev));
     object_unref(OBJECT(xendev));
@@ -532,11 +531,6 @@ int xen_be_init(void)
         goto err;
     }
 
-    xen_sysdev = qdev_create(NULL, TYPE_XENSYSDEV);
-    qdev_init_nofail(xen_sysdev);
-    xen_sysbus = qbus_create(TYPE_XENSYSBUS, DEVICE(xen_sysdev), "xen-sysbus");
-    qbus_set_bus_hotplug_handler(xen_sysbus, &error_abort);
-
     return 0;
 
 err:
@@ -624,7 +618,7 @@ static void xendev_class_init(ObjectClass *klass, void *data)
 
 static const TypeInfo xendev_type_info = {
     .name          = TYPE_XENBACKEND,
-    .parent        = TYPE_XENSYSDEV,
+    .parent        = TYPE_DEVICE,
     .class_init    = xendev_class_init,
     .instance_size = sizeof(struct XenDevice),
 };
diff --git a/include/monitor/dp-monitor.h b/include/monitor/dp-monitor.h
new file mode 100644
index 0000000..6e4239c
--- /dev/null
+++ b/include/monitor/dp-monitor.h
@@ -0,0 +1,9 @@
+#ifndef DP_MONITOR_H
+#define DP_MONITOR_H
+
+#include "chardev/char.h"
+
+void dp_monitor_init(Chardev *chr);
+void dp_monitor_destroy(void);
+
+#endif
diff --git a/include/qapi/qmp/dispatch.h b/include/qapi/qmp/dispatch.h
index 20578dc..2a7ff7c 100644
--- a/include/qapi/qmp/dispatch.h
+++ b/include/qapi/qmp/dispatch.h
@@ -16,6 +16,7 @@
 
 #include "qapi/qmp/qobject.h"
 #include "qapi/qmp/qdict.h"
+#include "qemu/thread.h"
 
 typedef void (QmpCommandFunc)(QDict *, QObject **, Error **);
 
@@ -54,4 +55,5 @@ typedef void (*qmp_cmd_callback_fn)(QmpCommand *cmd, void *opaque);
 void qmp_for_each_command(QmpCommandList *cmds, qmp_cmd_callback_fn fn,
                           void *opaque);
 
+extern QemuRecMutex monitor_rec_lock;
 #endif
diff --git a/monitor.c b/monitor.c
index 6aaa85a..acc43de 100644
--- a/monitor.c
+++ b/monitor.c
@@ -213,6 +213,7 @@ struct Monitor {
 
 /* Protects mon_list, monitor_event_state.  */
 static QemuMutex monitor_lock;
+QemuRecMutex monitor_rec_lock;
 
 static QLIST_HEAD(mon_list, Monitor) mon_list;
 static QLIST_HEAD(mon_fdsets, MonFdset) mon_fdsets;
diff --git a/qemu-dp.c b/qemu-dp.c
new file mode 100644
index 0000000..eec9c68
--- /dev/null
+++ b/qemu-dp.c
@@ -0,0 +1,156 @@
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "qemu-common.h"
+#include "qemu/main-loop.h"
+#include "qemu/log.h"
+#include "qemu/config-file.h"
+#include "crypto/init.h"
+#include "chardev/char.h"
+#include "dp-qmp-commands.h"
+#include "sysemu/iothread.h"
+#include "hw/xen/xen_backend.h"
+#include "hw/xen/xen_pvdev.h"
+#include "monitor/dp-monitor.h"
+
+/* Normally provided by vl.c */
+enum xen_mode xen_mode = XEN_ATTACH;
+bool xen_allowed = true;
+uint32_t xen_domid;
+bool xen_domid_restrict;
+/* Normally provided by xen_common.c */
+xc_interface *xen_xc;
+xenforeignmemory_handle *xen_fmem;
+xendevicemodel_handle *xen_dmod;
+
+#define QEMU_ARCH_I386 (1 << 3)
+const uint32_t arch_type = QEMU_ARCH_I386; /* arch_init.c */
+const char *qemu_name = "qemu-dp"; /* vl.c */
+
+/* Normally provided by cpus.c */
+static QemuMutex qemu_global_mutex;
+static __thread bool iothread_locked = false;
+
+static bool run_loop = true;
+
+void qmp_quit(Error **errp)
+{
+    /* Stop the main loop when the quit QMP command is executed. */
+    run_loop = false;
+}
+
+/* Normally provided by cpus.c */
+bool qemu_mutex_iothread_locked(void)
+{
+    return iothread_locked;
+}
+
+void qemu_mutex_lock_iothread(void)
+{
+    g_assert(!qemu_mutex_iothread_locked());
+    qemu_mutex_lock(&qemu_global_mutex);
+    iothread_locked = true;
+}
+
+void qemu_mutex_unlock_iothread(void)
+{
+    g_assert(qemu_mutex_iothread_locked());
+    iothread_locked = false;
+    qemu_mutex_unlock(&qemu_global_mutex);
+}
+
+static void qemu_dp_trace_init_events(const char *fname)
+{
+    FILE *fp;
+    char line_buf[1024];
+
+    if (fname == NULL) {
+        return;
+    }
+
+    fp = fopen(fname, "r");
+    if (!fp) {
+        /* just return if file is not there */
+        return;
+    }
+    while (fgets(line_buf, sizeof(line_buf), fp)) {
+        size_t len = strlen(line_buf);
+        if (len > 1) {              /* skip empty lines */
+            line_buf[len - 1] = '\0';
+            if ('#' == line_buf[0]) { /* skip commented lines */
+                continue;
+            }
+            trace_enable_events(line_buf);
+        }
+    }
+    if (fclose(fp) != 0) {
+        exit(1);
+    }
+}
+
+int main(int argc, char **argv)
+{
+    Error *err = NULL;
+    char *qmparg;
+    Chardev *chr;
+    QemuOpts *opts;
+
+    module_call_init(MODULE_INIT_TRACE);
+    qcrypto_init(&error_fatal);
+    module_call_init(MODULE_INIT_QOM);
+
+    if (argc != 2) {
+        printf("Usage: %s <qmp-socket-path>\n", argv[0]);
+        exit(1);
+    }
+
+    if (!trace_init_backends()) {
+        exit(1);
+    }
+
+    qemu_dp_trace_init_events("/usr/lib64/xen/bin/qemu-dp-tracing");
+
+    if (qemu_init_main_loop(&err)) {
+        error_report_err(err);
+        exit(EXIT_FAILURE);
+    }
+
+    qemu_mutex_init(&qemu_global_mutex);
+    qemu_mutex_lock_iothread();
+
+    qemu_add_opts(&qemu_chardev_opts);
+    qmparg = g_strdup_printf("unix:%s,server,nowait", argv[1]);
+    opts = qemu_chr_parse_compat("monitor0", qmparg);
+    g_free(qmparg);
+    chr = qemu_chr_new_from_opts(opts, &error_abort);
+
+    dp_monitor_init(chr);
+
+    bdrv_init();
+
+    xen_xc = xc_interface_open(0, 0, 0);
+    if (xen_xc == NULL) {
+        fprintf(stderr, "can't open xen interface\n");
+        exit(1);
+    }
+    xen_fmem = xenforeignmemory_open(0, 0);
+    if (xen_fmem == NULL) {
+        fprintf(stderr, "can't open xen fmem interface\n");
+        exit(1);
+    }
+
+    /* Initialize backend core & drivers */
+    if (xen_be_init() != 0) {
+        fprintf(stderr, "%s: xen backend core setup failed\n", __FUNCTION__);
+        exit(1);
+    }
+
+    while (run_loop)
+        main_loop_wait(false);
+
+    iothread_stop_all();
+    bdrv_close_all();
+    dp_monitor_destroy();
+    qemu_chr_cleanup();
+
+    return 0;
+}
diff --git a/trace-events b/trace-events
index 1d2eb5d..1e03146 100644
--- a/trace-events
+++ b/trace-events
@@ -48,6 +48,10 @@ monitor_protocol_event_queue(uint32_t event, void *qdict, uint64_t rate) "event=
 handle_hmp_command(void *mon, const char *cmdline) "mon %p cmdline: %s"
 handle_qmp_command(void *mon, const char *req) "mon %p req: %s"
 
+# dp-monitor.c
+dp_handle_qmp_command_enter(const char *req) "req: %s"
+dp_handle_qmp_command_exit(const char *req) "req: %s"
+
 # dma-helpers.c
 dma_blk_io(void *dbs, void *bs, int64_t offset, bool to_dev) "dbs=%p bs=%p offset=%" PRId64 " to_dev=%d"
 dma_aio_cancel(void *dbs) "dbs=%p"
